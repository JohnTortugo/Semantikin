#include "DataFlowAnalysis.h"

#include <iostream>

namespace DFA {

bool InstrComp(Instruction_sptr a, Instruction_sptr b) {
	return a.get() < b.get();
}

ReachingDefinitions::ReachingDefinitions(BasicBlock_list_sptr bbs) : _bbs(bbs) {
	// Compute Def[t], where t is a 'variable' name and Def[*] is a list of all
	// instructions that define 't'.
	for (auto& bb : *_bbs) {
		for (auto& instr : bb->instructions()) {
			if ( IR::isADefinition(instr.shared_from_this()) ) {
				auto tgt = IR::whatIsDefined(instr.shared_from_this());

				if (_defs.find(tgt) == _defs.end())
					_defs[tgt] = make_shared<Instruction_list>();

				this->_defs[tgt]->push_back(instr.shared_from_this());
			}
		}
	}

	for (auto& row : _defs) {
		sort(row.second->begin(), row.second->end(), InstrComp);
	}

	// Compute the Kill[i] and Gen[i] sets, where 'i' is an instruction
	// and Kill[*] is the set of all instruction/definitions that are killed by
	// the current instruction and Gen[i] is the set of instruction/definitions
	// generated by the current instruction.
	for (auto& bb : *_bbs) {
		for (auto& ins : bb->instructions()) {
			auto instr = ins.shared_from_this();

			if ( IR::isADefinition(instr) ) {
				_gen[instr] = make_shared<Instruction_list>();
				_gen[instr]->push_back(instr);

				_kill[instr] = make_shared<Instruction_list>();

				auto df = _defs[ IR::whatIsDefined(instr) ];

//				std::set_intersection(	df->begin(), df->end(), 
//										_gen[instr]->begin(), _gen[instr]->end(), 
//										_kill[instr]->begin());
			}
			else {
				_gen[instr] = make_shared<Instruction_list>();
				_kill[instr] = make_shared<Instruction_list>();
			}
		}
	}


}

void ReachingDefinitions::execute() {
	std::cout << "Going to execute RD. There are " << _defs.size() << " defs. " << std::endl;
}

}
